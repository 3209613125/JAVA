抽象方法，指的是声明而未实现的方法，它只不过是在普通的类的基础上扩充了一些抽象类罢了，没有方法体，他所在的类中和方法都要
用abstract来修饰
抽象类不象具体类那样描述一类具体事物，它是提取多种具有相似性的具体事物的共同特征而产生的
 比如，helicoptor, jet, fighter父类plane，有start(),takeOff(),speedUp(),changeDirection()等方法，
 这是共性，但现实中有一个具体的plane吗？没有，它是抽象出来的，根本不存在。所以实例化一个plane是没有意义的，
 因此面向对象程序设计机制禁止对象实例化，抽象类中禁止实例化对象
抽象类一定不能用final声明，因为final不能有子类，而抽象类一定含有子类，相应的，抽象方法也不能含有private来修饰
因为private修饰的方法不能被覆写，而抽象方法则一定要被覆写
private和abstract不能同时使用
抽象类必须有子类，且子类必须重新覆写该抽象父类的抽象方法，例如抽象类Person，子类Student，
 Person per=new Student（),per.play()(实例化子类，向上转型）
普通方法可以有返回值也可以没有返回值，而构造方法一定没有返回值，也没有static，final，abstract等词的修饰，
构造方法一定不能有void（）否则便不再是构造方法

构造方法是一种特殊的方法，具有以下特点。
（1）构造方法的方法名必须与类名相同。
（2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。
（3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。
（4）构造方法不能由编程人员调用，而要系统调用。
（5）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构  造器，这个构造器不执行任何代码。
（6）构造方法可以重载，以参数的个数，类型，或排列顺序区分。 
其实英文翻译其实为构造器，根本就不是一个方法，所以没有返回值

 分为有参构造和无参构造
abstract class Test {
    private String name; // 属性

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;

    }
}

若父类的属性为private私有的话，那么该属性便不可以被子类访问

    父类private的属性和方法子类可以继承但是不能访问和重写，在子类开辟的时候，内存会分配一个空间在子类的外部写上
    父类的属性和方法，包括私有属性和私有方法，在子类的内部空间写上它自己的数性和方法，两者加在一起就构成了子类的完整
    但是也可以通过父类的方法调用来访问其私有属性，但前提是父类方法中本身就包含其私有属性和私有方法的话，而且该方法不可以是私有的
    可以用父类的public方法来间接使用其私有属性


Integer默认值为null，int默认值为0

验证静态方法可以不直接实例化对象，通过类来调用
以及虽然通过主方法像构造方法里面传递参数，但是在类里面若定义了该属性的参数，那么this.属性的值依然还是类里面初始化的值




另外，抽象类也分为外部抽象类和内部抽象类，外部抽象类无法用static来修饰，而内部抽象类可以用static来修饰

模板设计模式，ocp原则，开闭原则，以咖啡机例子为例

final表示最终的意思，它修饰的类是不能被继承的；final修饰的方法能被继承（Math类里就有），
 但是不能够被重写。其实关系并不复杂，你只需要记住这样一句话：final可用于声明属性、方法和类，
 分别表示属性不可变，方法不可重写，类不可继承。
但是final修饰的方法可以被方法重载
子类向上转型为父类实例化对象，如果子类覆写了父类的方法，则实例化对象后，引用子类的方法，如果没有覆写父类的方法
则使用父类的方法

